<!DOCTYPE html><html dir="ltr" lang="en"><head><title>Lessons learned from BitWeav — Part. 1 — Liam Z. Edwards-Playne</title><meta content="Home of Liam Z." property="og:site_name"><meta content="Lessons learned from BitWeav — Part. 1 — Liam Z. Edwards-Playne" property="og:title"><meta content="article" property="og:type"><meta name="description" content="I have a new approach to BitWeav’s product design that focuses on the user: I’ve decided to design the BitWeav project from a topdown perspective. Instead of implementing the backend daemon first and then changing it later to support features needed by the frontend graphical client, I’m designing the graphical client first. I’ve already seen some of the benefits of doing this: when I was sketching the UI the other day, I found that I needed to implement a favourites mechanism. I knew that this was an essential part of the micropublishing framework, so I had to implement it at daemon level later. This is where my new top-down approach has improved the workflow: I’m spending more time designing for the user, and less time designing for the computer. Now this won’t work in all situations: when you’re under constraint by time or resources, and you haven’t devised a complete solution outline (like a design document, a whitepaper), you need to know the extent to what you’re doing before doing the frontend stuff first."><meta property="og:description" content="I have a new approach to BitWeav’s product design that focuses on the user: I’ve decided to design the BitWeav project from a topdown perspective. Instead of implementing the backend daemon first and then changing it later to support features needed by the frontend graphical client, I’m designing the graphical client first. I’ve already seen some of the benefits of doing this: when I was sketching the UI the other day, I found that I needed to implement a favourites mechanism. I knew that this was an essential part of the micropublishing framework, so I had to implement it at daemon level later. This is where my new top-down approach has improved the workflow: I’m spending more time designing for the user, and less time designing for the computer. Now this won’t work in all situations: when you’re under constraint by time or resources, and you haven’t devised a complete solution outline (like a design document, a whitepaper), you need to know the extent to what you’re doing before doing the frontend stuff first."><meta content="http:///bitweav-lessons-learned-part1/" property="og:url"><meta content="2013-09-03T00:00:00+10:00" property="article:published_time"><meta http-equiv="date" content="Tuesday, 03 2013 00:00:00 GMT"><meta content="http:///assets/img/portrait.png" property="og:image"><meta content="article" property="article:section"><meta content="Product design" property="article:tag"><link rel="alternate" type="application/rss+xml" href="/rss.xml" title="RSS Feed"><link rel="sitemap" type="application/xml" href="/sitemap.xml" title="Sitemap"><link rel="source" href="https://github.com/liamzebedee/jekyll-html5-template" title="Source Code"><link rel="icon" type="image/png" href="/assets/img/portrait-round.png"><link rel="apple-touch-icon-precomposed" href="/assets/img/portrait.png"><link href='/assets/global-563bc85bf7f9960683b206315f4b3fe2.css' rel='stylesheet' type='text/css'/><meta http-equiv="X-UA-Compatible" content="chrome=1"><meta charset="utf-8"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="cache-control" content="max-age=0"/><meta http-equiv="cache-control" content="no-cache"/><meta http-equiv="expires" content="0"/><meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/><meta http-equiv="pragma" content="no-cache"/><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js"></script></head><body id="container" class="post" itemscope itemtype="http://schema.org/WebPage"><div id="page"><aside id="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="wrap"> <header id="masthead" itemscope itemtype="http://schema.org/WPHeader"> <a href="/"><div id="portrait"></div></a><h1 id="brand">Home of Liam Z.</h1><h2 id="tagline"><small>Learner, hacker, thinker.</small></h2> </header> <nav id="menu"><ul class="unstyled" role="menu"><li role="menuitem" itemscope itemtype="http://schema.org/SiteNavigationElement"><h3><a href="/about/">About me</a></h3></li><li role="menuitem" itemscope itemtype="http://schema.org/SiteNavigationElement"><h3><a href="/endeavours/">Endeavours</a></h3></li><li role="menuitem" itemscope itemtype="http://schema.org/SiteNavigationElement"><h3><a href="/contact/">Contact</a></h3></li></ul> </nav></div> </aside><article id="content" itemscope itemtype="http://schema.org/Article"><div class="wrap"> <header> <span class="category label">article</span> <span class="topic label">Product design</span> <span class="muted">— <time class="timeago" datetime="2013-09-03T00:00:00Z" pubdate itemprop="datePublished">03 Sep 2013</time> </span><h1 itemprop="headline">Lessons learned from BitWeav — Part. 1</h1> </header><div itemprop="articleBody"><p class="lead"></p><p>I have a new approach to BitWeav’s product design that focuses on the user: I’ve decided to design the BitWeav project from a topdown perspective. Instead of implementing the backend daemon first and then changing it later to support features needed by the frontend graphical client, I’m designing the graphical client first. I’ve already seen some of the benefits of doing this: when I was sketching the UI the other day, I found that I needed to implement a favourites mechanism. I knew that this was an essential part of the micropublishing framework, so I had to implement it at daemon level later. This is where my new top-down approach has improved the workflow: I’m spending more time <strong>designing for the user</strong>, and less time <strong>designing for the computer</strong>. Now this won’t work in all situations: when you’re under constraint by time or resources, and you haven’t devised a complete solution outline (like a design document, a whitepaper), you need to know the extent to what you’re doing before doing the frontend stuff first.</p><p>I’ve also had an epiphany about how I can make the user experience more natural and holistic. Before, you see, I had an entire button in the menu bar for displaying a ‘Write’ dialog. It contained fields for the message it’s in reply to, a thread it could be part of, as well as a language field. Finally there was the textarea, for the actual content of the message. What was the problem? The entire nature of this control was apart from the crowd; it didn’t unite contextually with the various pages of the application. No-one is going to reply to a message by clicking write and then inserting the message’s ID. No-one cares what thread they are replying on, they just want to be able to distinguish between the various items of conversation they’ve had. So here’s what I did: I <strong>united the write dialog with the rest of the interface and made it context-based</strong>. Now to reply to something, it’s simply a button below the message.</p><p>Thirdly, I am reminded of how analysis enables deepeer appreciation of things. While building the BitWeav graphical client, I’ve taken a lot of inspiration from Twitter. This is partly due to my lacking in design skills (something I would love to improve), but is mainly because of how wonderful Twitter is. It’s just the small things that I, a novice, wouldn’t think of at first. For example, the textarea for writing a message. Previously I had set a textarea of around 5 rows which would be enough to fit the maximum of 200 characters I had set for message composition. This wasn’t optimal for two reasons as these 5 rows consumed a lot of vertical space, and it wasn’t certain that all 200 chars would be used. So instead I mimicked what Twitter did: they kept the textarea to a single row, and as the user typed more characters it expanded accordingly — it’s this simple detail that helps construct the user experience. For another example, take a look at how content is displayed. My initial instinct was to utilise the largest vertical space possible, displaying content in three to four columns. Still, given my previous discovery I thought it was worth looking into <a href='http://ux.stackexchange.com/questions/43891/1-column-vs-n-column-timelines-news-feeds'>why Twitter only uses one column for the feed</a>:</p><blockquote><p>If the items in the timeline are arranged in chronological order, that order should immediately obvious in the layout. … A single timeline cannot be presented over multiple columns without inducing a level of confusion.</p></blockquote><p>Of course! The very nature of microblogging plays significantly into the aspect of time. With a number of extra columns it would be undeniably confusing to the user, both for navigation and chronology of events.</p><p>Through analysis we can discover these subtle choices and thus greater appreicate the work. I’ve found this same idea in literature as well: when I first read <a href='/we-zamyatin/'>We</a>, I thought it was a reasonably good novel. It wasn’t until I understood the context in which it was written, and had analysed the various themes and motifs that I began to recognise what a great work it was. Subtle details contained only in single sentences, such as how the citizens of the city consume a petroleum-based food, that aid in constructing whole motifs of how these people were units in a machine, their food source being that of machines. So that is my objective for this month: to greater appreciate things through greater attention to the world around me.</p><hr/><p>On another note, I’ve stumbled upon a friendly way to pitch BitWeav: the first open microblogging network built entirely by those who use it. It resembles the philosophy of the <a href='http://indiewebcamp.com/'>IndieWeb</a>; an indie Twitter if you may?</p></div></div></article></div><script src='/assets/global-5d4664777616a94042a01bf3274f5aa6.js'></script></body></html>